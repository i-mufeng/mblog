---
readingTime: false
hidden: true
---

## 11-4

### execute 与 submit 的用法与区别。

execute 执行后**没有返回结果**，只有1种用法

| 方法                               | 描述                                          |
|----------------------------------|---------------------------------------------|
| `void execute(Runnable command)` | 常规使用方法，用没有返回值的 execute 执行没有返回值的 Runnable 任务 |

submit 执行后**有返回结果**，有3种用法

| 方法                                       | 描述                                        |
|------------------------------------------|-------------------------------------------|
| `Future submit(Callable task)`           | 常规使用方法，传入有返回值的 callable 任务，最终返回 task 的返回值 |
| `Future submit(Runnable task, T result)` | 由于 Runnable 没有返回值，但是可以自定义一个返回值用于返回        |
| `Future submit(Runnable task)`           | 强行使用 submit 执行 Runnable 方法，忽略返回值          |

## 11-3

### Runnable 与 Callable 的区别。

Runnable 没有返回结果，即没有 return 语句；Callable 有返回结果。

可以通过 Executors 工厂类将 Runnable 封装为一个 Callable 对象。

## 11-2

### 请描述 Executor 框架的执行过程。

1、通过实现 Runnable 接口或 Callable 接口创建任务。

2、通过Executors的工厂方法创建线程池。

3、通过 `ExecutorService.submit()`
提交一个有返回结果的任务，返回类型为一个实现Future接口的对象；或通过ExecutorService.execute()方法执行一个没有返回结果的任务。

4、通过 `FutureTask.get()` 获取返回结果（如果有）。

## 11-1

### 说一说你理解的 Executor 框架。

Executor 是线程池的调度工具，线程池是 Executor 的一部分。

Executor 框架由三大部分组成

1、**任务**：即被执行任务需要实现的接口：**Runnable** 接口或 **Callable** 接口。

2、**线程池**：主要通过 **ExecutorService** 接口调用线程池，有2个关键实现类 **ThreadPoolExecutor** 和 *
*ScheduledThreadPoolExecutor**。

3、**异步计算的结果**：**Future** 接口及其实现类 **FutureTask**。
