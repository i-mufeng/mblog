---
readingTime: false
hidden: true
---

## 11-7

### 创建线程有哪几种方式？

1. 继承 Thread 类，重写 run() 方法，调用 start() 方法启动线程。
2. 实现 Runnable 接口，重写 run() 方法，创建 Thread 对象，调用 start() 方法启动线程。
3. 实现 Callable 接口，重写 call() 方法，创建 FutureTask 对象，创建 Thread 对象，调用 start() 方法启动线程。
4. 使用线程池创建线程。

## 11-6

### 都有哪些原子类？请举例说明。

`java.util.concurrent `这个包里面提供了一组原子类。其基本的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性。

- 原子类：AtomicBoolean，AtomicInteger，AtomicLong，AtomicReference
- 原子数组：AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray
- 原子属性更新器：AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater
- 解决ABA问题的原子类：AtomicMarkableReference（通过引入一个boolean来反映中间有没有变过），AtomicStampedReference（通过引入一个int来累加来反映中间有没有变过）


## 11-5

### 什么是原子操作?

原子操作（atomic operation）意为”不可被中断的一个或一系列操作” 。处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作。
在Java中可以通过锁和循环CAS的方式来实现原子操作。CAS操作——Compare & Set，或是 Compare & Swap，现在几乎所有的CPU指令都支持CAS的原子操作。

原子操作是指一个不受其他操作影响的操作任务单元。原子操作是在多线程环境下避免数据不一致必须的手段。
`int++` 并不是一个原子操作，所以当一个线程读取它的值并加1时，另外一个线程有可能会读到之前的值，这就会引发错误。

为了解决这个问题，必须保证增加操作是原子的，在JDK1.5之前我们可以使用同步技术来做到这一点。
到JDK1.5，java.util.concurrent.atomic包提供了int和long类型的原子包装类，它们可以自动的保证对于他们的操作是原子的并且不需要使用同步。

## 11-4

### execute 与 submit 的用法与区别。

execute 执行后**没有返回结果**，只有1种用法

| 方法                               | 描述                                          |
|----------------------------------|---------------------------------------------|
| `void execute(Runnable command)` | 常规使用方法，用没有返回值的 execute 执行没有返回值的 Runnable 任务 |

submit 执行后**有返回结果**，有3种用法

| 方法                                       | 描述                                        |
|------------------------------------------|-------------------------------------------|
| `Future submit(Callable task)`           | 常规使用方法，传入有返回值的 callable 任务，最终返回 task 的返回值 |
| `Future submit(Runnable task, T result)` | 由于 Runnable 没有返回值，但是可以自定义一个返回值用于返回        |
| `Future submit(Runnable task)`           | 强行使用 submit 执行 Runnable 方法，忽略返回值          |

## 11-3

### Runnable 与 Callable 的区别。

Runnable 没有返回结果，即没有 return 语句；Callable 有返回结果。

可以通过 Executors 工厂类将 Runnable 封装为一个 Callable 对象。

## 11-2

### 请描述 Executor 框架的执行过程。

1、通过实现 Runnable 接口或 Callable 接口创建任务。

2、通过Executors的工厂方法创建线程池。

3、通过 `ExecutorService.submit()`
提交一个有返回结果的任务，返回类型为一个实现Future接口的对象；或通过ExecutorService.execute()方法执行一个没有返回结果的任务。

4、通过 `FutureTask.get()` 获取返回结果（如果有）。

## 11-1

### 说一说你理解的 Executor 框架。

Executor 是线程池的调度工具，线程池是 Executor 的一部分。

Executor 框架由三大部分组成

1、**任务**：即被执行任务需要实现的接口：**Runnable** 接口或 **Callable** 接口。

2、**线程池**：主要通过 **ExecutorService** 接口调用线程池，有2个关键实现类 **ThreadPoolExecutor** 和 *
*ScheduledThreadPoolExecutor**。

3、**异步计算的结果**：**Future** 接口及其实现类 **FutureTask**。
