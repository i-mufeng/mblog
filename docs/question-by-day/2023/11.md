---
readingTime: false
hidden: true
---

## 11-8

### 线程的状态有哪些？

1. 新建状态（New）：当线程对象对创建后，即进入了新建状态; 
2. 就绪状态（Runnable）：当调用线程对象的 `start()` 方法，线程即进入就绪状态。
3. 运行状态（Running）：当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。
4. 阻塞状态（Blocked）：处于运行状态中的线程由于某种原因，暂时放弃对 CPU 的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被 CPU 调用以进入到运行状态。
根据阻塞产生的原因不同，阻塞状态又可以分为三种： 
    - 等待阻塞：运行状态中的线程执行 `wait()` 方法，使本线程进入到等待阻塞状态； 
    - 同步阻塞 — 线程在获取 synchronized 同步锁失败（因为锁被其它线程所占用），它会进入同步阻塞状态； 
    - 其他阻塞 — 通过调用线程的 `sleep()` 或 `join()` 或发出了I/O请求时，线程会进入到阻塞状态。当 `sleep()` 状态超时. `join()` 等待线程终止或者超时. 或者 I/O 处理完毕时，线程重新转入就绪状态。 
5. 死亡状态（Dead）：线程执行完了或者因异常退出了 `run()` 方法，该线程结束生命周期。

## 11-7

### 创建线程有哪几种方式？

1. 继承 Thread 类，重写 run() 方法，调用 start() 方法启动线程。
2. 实现 Runnable 接口，重写 run() 方法，创建 Thread 对象，调用 start() 方法启动线程。
3. 实现 Callable 接口，重写 call() 方法，创建 FutureTask 对象，创建 Thread 对象，调用 start() 方法启动线程。
4. 使用线程池创建线程。

> 使用线程池的方式创建是最优解，因为线程池可以有效的控制线程的数量，避免因为创建线程过多导致的内存溢出，提高了系统资源的利用率，同时线程池提供了更多更强大的功能。

## 11-6

### 都有哪些原子类？请举例说明。

`java.util.concurrent `这个包里面提供了一组原子类。其基本的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性。

- 原子类：AtomicBoolean，AtomicInteger，AtomicLong，AtomicReference
- 原子数组：AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray
- 原子属性更新器：AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater
- 解决ABA问题的原子类：AtomicMarkableReference（通过引入一个boolean来反映中间有没有变过），AtomicStampedReference（通过引入一个int来累加来反映中间有没有变过）


## 11-5

### 什么是原子操作?

原子操作（atomic operation）意为”不可被中断的一个或一系列操作” 。处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作。
在Java中可以通过锁和循环CAS的方式来实现原子操作。CAS操作——Compare & Set，或是 Compare & Swap，现在几乎所有的CPU指令都支持CAS的原子操作。

原子操作是指一个不受其他操作影响的操作任务单元。原子操作是在多线程环境下避免数据不一致必须的手段。
`int++` 并不是一个原子操作，所以当一个线程读取它的值并加1时，另外一个线程有可能会读到之前的值，这就会引发错误。

为了解决这个问题，必须保证增加操作是原子的，在JDK1.5之前我们可以使用同步技术来做到这一点。
到JDK1.5，java.util.concurrent.atomic包提供了int和long类型的原子包装类，它们可以自动的保证对于他们的操作是原子的并且不需要使用同步。

## 11-4

### execute 与 submit 的用法与区别。

execute 执行后**没有返回结果**，只有1种用法

| 方法                               | 描述                                          |
|----------------------------------|---------------------------------------------|
| `void execute(Runnable command)` | 常规使用方法，用没有返回值的 execute 执行没有返回值的 Runnable 任务 |

submit 执行后**有返回结果**，有3种用法

| 方法                                       | 描述                                        |
|------------------------------------------|-------------------------------------------|
| `Future submit(Callable task)`           | 常规使用方法，传入有返回值的 callable 任务，最终返回 task 的返回值 |
| `Future submit(Runnable task, T result)` | 由于 Runnable 没有返回值，但是可以自定义一个返回值用于返回        |
| `Future submit(Runnable task)`           | 强行使用 submit 执行 Runnable 方法，忽略返回值          |

## 11-3

### Runnable 与 Callable 的区别。

Runnable 没有返回结果，即没有 return 语句；Callable 有返回结果。

可以通过 Executors 工厂类将 Runnable 封装为一个 Callable 对象。

## 11-2

### 请描述 Executor 框架的执行过程。

1、通过实现 Runnable 接口或 Callable 接口创建任务。

2、通过Executors的工厂方法创建线程池。

3、通过 `ExecutorService.submit()`
提交一个有返回结果的任务，返回类型为一个实现Future接口的对象；或通过ExecutorService.execute()方法执行一个没有返回结果的任务。

4、通过 `FutureTask.get()` 获取返回结果（如果有）。

## 11-1

### 说一说你理解的 Executor 框架。

Executor 是线程池的调度工具，线程池是 Executor 的一部分。

Executor 框架由三大部分组成

1、**任务**：即被执行任务需要实现的接口：**Runnable** 接口或 **Callable** 接口。

2、**线程池**：主要通过 **ExecutorService** 接口调用线程池，有2个关键实现类 **ThreadPoolExecutor** 和 *
*ScheduledThreadPoolExecutor**。

3、**异步计算的结果**：**Future** 接口及其实现类 **FutureTask**。
