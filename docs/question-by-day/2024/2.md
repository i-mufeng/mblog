---
readingTime: false
hidden: true
---

## 2-6

### 所有的 final 修饰的字段都是编译期常量吗?

不是，final 修饰的字段，如果是基本数据类型或者是不可变对象，那么它是编译期常量，否则不是。

```java
public class FinalTest {
    public final int a = 6;     // 编译期常量
    public final int b = new Random().nextInt(100);     // 运行期常量
    public static final int c = 6;      // 编译期常量
    public static final int d = new Random().nextInt(100);      // 运行期常量
    public final String e = "hello";      // 运行期常量
    public final String f = new String("hello");      // 运行期常量
}
```

## 2-5

### 什么是重复注解？

重复注解指允许在同一申明类型(类，属性，或方法)的多次使用同一个注解。

在 JAVA 之前，对于重复注解的解决方案如下，不是很友好：

```java
public @interface Authority {
     String role();
}

public @interface Authorities {
    Authority[] value();
}

public class RepeatAnnotationUseOldVersion {

    @Authorities({@Authority(role="Admin"),@Authority(role="Manager")})
    public void doSomeThing(){
    }
}
```

JAVA 8 之后：

```java
@Repeatable(Authorities.class)
public @interface Authority {
String role();
}

public @interface Authorities {
Authority[] value();
}

public class RepeatAnnotationUseNewVersion {
@Authority(role="Admin")
@Authority(role="Manager")
public void doSomeThing(){ }
}
```

## 2-4

### 什么是类型注解？

注解类型被用来支持在 JAVA 程序中做强类型检查。配合插件式的 `check framework`，可以在编译时检测出 runtime error，以提高代码质量。

创建类实例：`new @Interned MyObject();`

类型映射：`myString = (@NonNull String) str;`

implements 语句中：`class UnmodifiableList<T> implements @Readonly List<@Readonly T> { … }`

throw exception 声明：`void monitorTemperature() throws @Critical TemperatureException { … }`

> 类型注解只是语法而不是语义，并不会影响 java 的编译时间，加载时间，以及运行时间，也就是说，编译成 class 文件的时候并不包含类型注解。

## 2-3

### Optional 要解决什么问题？

在调用一个方法得到了返回值却不能直接将返回值作为参数去调用别的方法，我们首先要判断这个返回值是否为 null，
只有在非空的前提下才能将其作为其他方法的参数。Java 8 引入了一个新的 Optional 类：这是一个可以为 null 的容器对象，
如果值存在则 `isPresent()` 方法会返回 true，调用 `get()` 方法会返回该对象。

```java
Optional.of(new Outer())
    .map(Outer::getNested)
    .map(Nested::getInner)
    .map(Inner::getFoo)
    .ifPresent(System.out::println);
```

还有一种实现相同作用的方式就是通过利用一个 supplier 函数来解决嵌套路径的问题:
```java
Outer obj = new Outer();
resolve(() -> obj.getNested().getInner().getFoo())
    .ifPresent(System.out::println);
```
## 2-2

### 什么是 FunctionalInterface？

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface FunctionalInterface{}
```

FunctionalInterface 函数式接口，是 JAVA 8 中一类特殊类型接口的称呼，这种类只包含一个抽象方法（除了隐含的 Object 对象的公共方法）

- 只能有一个抽象方法。
- 可以有多个静态方法和默认方法。
- 默认包含 Object 类的方法。

## 2-1

### 类加载的生命周期？

了加载的过程包括了 加载、验证。准备。解析、初始化五个阶段，
除了解析之外，其余阶段的顺序是确定的，解析阶段可以在初始化之后进行。

