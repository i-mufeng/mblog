---
readingTime: false
hidden: true
outline: 3
---

# 每日一题 - 202405

## 5-13

### JS 双色球机选一注

#### 描述

双色球由33个红球和16个蓝球组成，1注双色球包括6个不重复的红球和1个蓝球。
请阅读给出的页面和代码，完成 randomFn 函数，实现“随机一注”功能，要求如下：
函数返回：
`1.以字符串形式输出“随机一注”结果，选中的红蓝球用"|"隔开，红球在前，号码间用半角逗号隔开，如"06,10,13,18,23,27|05"
2.红球和蓝球号码排列顺序 需与页面展示的顺序对应`
页面交互：
1.将选中的红球和蓝球（页面中对应DOM元素）用class="active"高亮
2.将选中的球按号码从小到大排列，移至所属组的前方，结果如示意图所示
3.每次执行 randomFn 函数，输出符合要求且不完全重复

![img](https://uploadfiles.nowcoder.com/images/20180912/56_1536742847965_6A5DCE935C2B11A7798DAD3BC7BBD64B)

> 注意：
> 1、请使用原生JavaScript操作DOM元素，不要增加、删除DOM元素或修改css
> 2、请使用ES5语法
> 3、答题时不要使用第三方插件
>
> 4、运行浏览器为chrome浏览器
>
> 5、
>
> // 可能涉及的点
>
> // element.className
> // element.classList
> // element.classList.add
> // element.classList.remove
> // element.getAttribute
> // element.setAttribute
> // element.innerHTML
> // element.insertBefore
> // element.parentNode
>
> // document.querySelector
> // document.querySelectorAll
> // document.getElementsByTagName
> // document.getElementsByClassName
>
> // Array.sort
> // Array.push
> // Array.join
> // Array.indexOf
> // Array.forEach
> // Array.map
>
> // Math.random
> // Math.floor
>
> // Number.toString()

```html
<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <style>
       .main .balls {
    width: 450px;
    padding: 30px 10px 10px;
    margin-bottom: 20px;
    position: relative;
    border-radius: 4px;
}

.main .balls:after {
    content: '\20';
    clear: both;
    display: block;
    height: 0;
    overflow: hidden;
}

.main .balls span {
    position: absolute;
    left: 12px;
    top: 5px;
    font-size: 13px;
}

.main b {
    float: left;
    width: 30px;
    height: 30px;
    font-size: 15px;
    background: #FFF;
    border: 1px solid;
    border-radius: 50%;
    line-height: 30px;
    text-align: center;
    margin-right: 8px;
    margin-bottom: 8px;
    cursor: pointer;
}

.main .red .active {
    background: #f56c6c;
    color: #FFF;
}

.main .blue .active {
    background: #3a8ee6;
    color: #FFF;
}

.main .red {
    background: #feeff0;
}

.main .red b {
    border-color: #f56c6c;
}

.main .blue {
    background: #ecf8ff;
}

.main .blue b {
    border-color: #3a8ee6;
}
    </style>
</head>

<body>
    <!-- 填写标签 -->
    <div class="main">
    <div class="balls red">
        <span>红球</span>
        <div class="balls-wp">
            <b>01</b>
            <b>02</b>
            <b>03</b>
            <b>04</b>
            <b>05</b>
            <b>06</b>
            <b>07</b>
            <b>08</b>
            <b>09</b>
            <b>10</b>
            <b>11</b>
            <b>12</b>
            <b>13</b>
            <b>14</b>
            <b>15</b>
            <b>16</b>
            <b>17</b>
            <b>18</b>
            <b>19</b>
            <b>20</b>
            <b>21</b>
            <b>22</b>
            <b>23</b>
            <b>24</b>
            <b>25</b>
            <b>26</b>
            <b>27</b>
            <b>28</b>
            <b>29</b>
            <b>30</b>
            <b>31</b>
            <b>32</b>
            <b>33</b>
        </div>
    </div>
    <div class="balls blue">
        <span>蓝球</span>
        <div class="balls-wp">
            <b>01</b>
            <b>02</b>
            <b>03</b>
            <b>04</b>
            <b>05</b>
            <b>06</b>
            <b>07</b>
            <b>08</b>
            <b>09</b>
            <b>10</b>
            <b>11</b>
            <b>12</b>
            <b>13</b>
            <b>14</b>
            <b>15</b>
            <b>16</b>
        </div>
    </div>
</div>
    <script type="text/javascript">
        // 填写JavaScript
        randomFn();

function randomFn() {
	let redballs = document.querySelectorAll(".red .balls-wp b")
    let blueballs = document.querySelectorAll(".blue .balls-wp b")
    let reddiv = document.querySelector(".red .balls-wp")
    let bluediv = document.querySelector(".blue .balls-wp")
    let red = []
    let redB = []
    while(red.length<6)
    {
      let num=Math.floor(Math.random()*33)+1
      if(!red.includes(num))
      {
        red.push(num)
        let redb = redballs[num-1]
        redb.classList.add("active")
        redB.push(redb)
      }
    }
    let blue = Math.floor(Math.random()*16)+1
    let blueB = blueballs[blue-1]
    //不能直接接在后面写 因为add返回的是undefined
    blueB.classList.add("active")
    //按照从大到小 指的是b标签的内部
    redB = redB.sort((a,b)=>b.innerHTML-a.innerHTML)
    for(let i=0;i<6;i++)
    {
        redballs = document.querySelectorAll('.red .balls-wp b')
        //insertBefore是如果原来是子节点则将子节点移动到对应节点前面(删除原本位置)
        //反之如果原来不是子节点 则将新节点插入到对应节点前面
        reddiv.insertBefore(redB[i],redballs[0])
    }
    bluediv.insertBefore(blueB,blueballs[0])
    //因为涉及到06这种 而redb只是纯数值而已
    return redB.map(ball => ball.innerHTML).reverse().join(',') + '|' + blueB.innerHTML
}
    </script>
</body>

</html>
```


## 5-12

### JS 购物车

HTML模块为一个简化版的购物车，tbody为商品列表，tfoot为统计信息，系统会随机在列表中生成一些初始商品信息
`1、请完成add函数，在列表后面显示items商品信息。参数items为{name: String, price: Number}组成的数组
2、请完成bind函数，点击每一行的删除按钮(包括通过add增加的行)，从列表中删除对应行
3、请注意同步更新统计信息，价格保留小数点后两位
4、列表和统计信息格式请与HTML示例保持一致
5、不要直接手动修改HTML中的代码
6、不要使用第三方库`

```html
<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <style>
       /* 填写样式 */
        body,html{
    padding: 0;
    margin: 0;
    font-size: 14px;
    color: #000000;
}
table{
    border-collapse: collapse;
    width: 100%;
    table-layout: fixed;
}
thead{
    background: #3d444c;
    color: #ffffff;
}
td,th{
    border: 1px solid #e1e1e1;
    padding: 0;
    height: 30px;
    line-height: 30px;
    text-align: center;
}
    </style>
</head>

<body>
    <!-- 填写标签 -->
    <table id="jsTrolley">
    <thead><tr><th>名称</th><th>价格</th><th>操作</th></tr></thead>
    <tbody>
        <tr><td>产品1</td><td>10.00</td><td><a href="javascript:void(0);">删除</a></td></tr>
        <tr><td>产品2</td><td>30.20</td><td><a href="javascript:void(0);">删除</a></td></tr>
        <tr><td>产品3</td><td>20.50</td><td><a href="javascript:void(0);">删除</a></td></tr>
    </tbody>
    <tfoot><tr><th>总计</th><td colspan="2">60.70(3件商品)</td></tr></tfoot>
</table>
    <script type="text/javascript">
        // 填写JavaScript
        // 新增行
function add(items) {
    var tbody = document.getElementsByTagName('tbody')[0]
    var tfoot = document.getElementsByTagName('tfoot')[0]
    // 获取初始数据
    let count = tbody.children.length
    let price = parseFloat(tfoot.innerText.match(/\d+.\d+/)[0])
    // 新增行
    let tr = ''
    for (let i = 0; i < items.length; i++) {
        count += 1
        price += items[i].price
        tr += `<tr><td>${items[i].name}</td><td>${items[i].price.toFixed(2)}</td><td><a href="javascript:void(0);">删除</a></td></tr>`
    }
    tbody.innerHTML += tr
    tfoot.innerHTML = `<tr><th>总计</th><td colspan="2">${price.toFixed(2)}(${count}件商品)</td></tr>`
}

// 绑定事件，事件代理
function bind() {
    var tbody = document.getElementsByTagName('tbody')[0]
    var tfoot = document.getElementsByTagName('tfoot')[0]
    tbody.addEventListener('click', function (e) {
        let num = tbody.children.length
        console.log(tbody);
        // 过滤点击的是否是a标签
        if (e.target.tagName === "A") {
            // 获取数据
            let price = parseFloat(e.target.parentElement.parentElement.innerHTML.match(/\d+.\d+/)[0])
            let total = tfoot.innerHTML.match(/\d+.\d+/)[0]
            e.target.parentElement.parentElement.remove()
            tfoot.innerHTML = `<tr><th>总计</th><td colspan="2">${(total - price).toFixed(2)}(${num - 1}件商品)</td></tr>`
        }
    })
}
// 执行绑定事件
bind()
    </script>
</body>

</html>
```


## 5-11

### JS 数组排序

请补全JavaScript代码，根据预设代码中的数组，实现以下功能：

1. 列表只展示数组中的name属性
2. 实现点击"销量升序"按钮，列表内容按照销量升序重新渲染
3. 实现点击"销量降序"按钮，列表内容按照销量降序重新渲染

> 注意：
>
> 1. 必须使用DOM0级标准事件（onclick）

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
    </head>
    <body>
        <button class='up'>销量升序</button>
        <button class='down'>销量降序</button>
        <ul></ul>

        <script>
            var cups = [
                { type: 1, price: 100, color: 'black', sales: 3000, name: '牛客logo马克杯' },
                { type: 2, price: 40, color: 'blue', sales: 1000, name: '无盖星空杯' },
                { type: 4, price: 60, color: 'green', sales: 200, name: '老式茶杯' },
                { type: 3, price: 50, color: 'green', sales: 600, name: '欧式印花杯' }
            ]
            var ul = document.querySelector('ul');
            var upbtn = document.querySelector('.up');
            var downbtn = document.querySelector('.down');
            // 补全代码
             function ulRender() {
                ul.innerHTML = cups.map(v => `<li>${v.name}</li>`).join('');
            }
            upbtn.onclick = function () {
                cups.sort((a, b) => a.sales - b.sales);
                ulRender();
            }
            downbtn.onclick = function () {
                cups.sort((a, b) => b.sales - a.sales);
                ulRender();
            }
        </script>
    </body>
</html>
```


## 5-10

### JS模块编程题

#### 题目：

完成函数 createModule，调用之后满足如下要求：
1、返回一个对象
2、对象的 greeting 属性值等于 str1， name 属性值等于 str2
3、对象存在一个 sayIt 方法，该方法返回的字符串为 greeting属性值 + ', ' + name属性值

#### 题解：

```javascript
function createModule(str1, str2) {
    let res = {
        greeting: str1,
        name: str2,
    }
    res.sayIt = function() {
        return this.greeting + ', ' + this.name;
    }
    return res;
}
```


## 5-9

### computed 和 watch 的区别？

**computed：** 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed  的值；

**watch：** 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；


## 5-8

### webpack的构建流程？

#### 1、运行流程

`webpack` 的运行流程是一个串行的过程，它的工作流程就是将各个插件串联起来

在运行过程中会广播事件，插件只需要监听它所关心的事件，就能加入到这条`webpack`机制中，去改变`webpack`的运作，使得整个系统扩展性良好

从启动到结束会依次执行以下三大步骤：

- 初始化流程：从配置文件和 `Shell` 语句中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数
- 编译构建流程：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找到该 Module 依赖的 Module，递归地进行编译处理
- 输出流程：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统

![img](https://static.vue-js.com/b566d400-a658-11eb-85f6-6fac77c0c9b3.png)

#### 2、初始化流程

从配置文件和 `Shell` 语句中读取与合并参数，得出最终的参数

配置文件默认下为`webpack.config.js`，也或者通过命令的形式指定配置文件，主要作用是用于激活`webpack`的加载项和插件

`webpack` 将 `webpack.config.js` 中的各个配置项拷贝到 `options` 对象中，并加载用户配置的 `plugins`

完成上述步骤之后，则开始初始化`Compiler`编译对象，该对象掌控者`webpack`声明周期，不执行具体的任务，只是进行一些调度工作

#### 3、编译构建流程

根据配置中的 `entry` 找出所有的入口文件

```js
module.exports = {
  entry: './src/file.js'
}
```

初始化完成后会调用`Compiler`的`run`来真正启动`webpack`编译构建流程，主要流程如下：

- `compile` 开始编译
- `make` 从入口点分析模块及其依赖的模块，创建这些模块对象
- `build-module` 构建模块
- `seal` 封装构建结果
- `emit` 把各个chunk输出到结果文件

###### compile 编译

执行了`run`方法后，首先会触发`compile`，主要是构建一个`Compilation`对象

该对象是编译阶段的主要执行者，主要会依次下述流程：执行模块创建、依赖收集、分块、打包等主要任务的对象

###### make 编译模块

当完成了上述的`compilation`对象后，就开始从`Entry`入口文件开始读取，主要执行`_addModuleChain()`函数，如下：

```js
_addModuleChain(context, dependency, onModule, callback) {
   ...
   // 根据依赖查找对应的工厂函数
   const Dep = /** @type {DepConstructor} */ (dependency.constructor);
   const moduleFactory = this.dependencyFactories.get(Dep);
   
   // 调用工厂函数NormalModuleFactory的create来生成一个空的NormalModule对象
   moduleFactory.create({
       dependencies: [dependency]
       ...
   }, (err, module) => {
       ...
       const afterBuild = () => {
        this.processModuleDependencies(module, err => {
         if (err) return callback(err);
         callback(null, module);
           });
    };
       
       this.buildModule(module, false, null, null, err => {
           ...
           afterBuild();
       })
   })
}
```

过程如下：

`_addModuleChain`中接收参数`dependency`传入的入口依赖，使用对应的工厂函数`NormalModuleFactory.create`方法生成一个空的`module`对象

回调中会把此`module`存入`compilation.modules`对象和`dependencies.module`对象中，由于是入口文件，也会存入`compilation.entries`中

随后执行`buildModule`进入真正的构建模块`module`内容的过程

###### build module 完成模块编译

这里主要调用配置的`loaders`，将我们的模块转成标准的`JS`模块

在用`Loader` 对一个模块转换完后，使用 `acorn` 解析转换后的内容，输出对应的抽象语法树（`AST`），以方便 `Webpack`后面对代码的分析

从配置的入口模块开始，分析其 `AST`，当遇到`require`等导入其它模块语句时，便将其加入到依赖的模块列表，同时对新找出的依赖模块递归分析，最终搞清所有模块的依赖关系

#### 4、输出流程

###### seal 输出资源

`seal`方法主要是要生成`chunks`，对`chunks`进行一系列的优化操作，并生成要输出的代码

`webpack` 中的 `chunk` ，可以理解为配置在 `entry` 中的模块，或者是动态引入的模块

根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 `Chunk`，再把每个 `Chunk` 转换成一个单独的文件加入到输出列表

###### emit 输出完成

在确定好输出内容后，根据配置确定输出的路径和文件名

在 `Compiler` 开始生成文件前，钩子 `emit` 会被执行，这是我们修改最终文件的最后一个机会

从而`webpack`整个打包过程则结束了


## 5-7

### bind、call、apply 区别？

`call`、`apply`、`bind`作用是改变函数执行时的上下文，简而言之就是改变函数运行时的`this`指向

#### apply

`apply`接受两个参数，第一个参数是`this`的指向，第二个参数是函数接受的参数，以数组的形式传入

改变`this`指向后原函数会立即执行，且此方法只是临时改变`this`指向一次

#### call

`call`方法的第一个参数也是`this`的指向，后面传入的是一个参数列表

跟`apply`一样，改变`this`指向后原函数会立即执行，且此方法只是临时改变`this`指向一次

#### bind

bind方法和call很相似，第一参数也是`this`的指向，后面传入的也是一个参数列表(但是这个参数列表可以分多次传入)

改变`this`指向后不会立即执行，而是返回一个永久改变`this`指向的函数

> 从上面可以看到，`apply`、`call`、`bind`三者的区别在于：
>
> - 三者都可以改变函数的`this`对象指向
> - 三者第一个参数都是`this`要指向的对象，如果如果没有这个参数或参数为`undefined`或`null`，则默认指向全局`window`
> - 三者都可以传参，但是`apply`是数组，而`call`是参数列表，且`apply`和`call`是一次性传入参数，而`bind`可以分为多次传入
> - `bind`是返回绑定this之后的函数，`apply`、`call` 则是立即执行


## 5-6

### 如何理解this对象？

函数的 `this` 关键字在 `JavaScript` 中的表现略有不同，此外，在严格模式和非严格模式之间也会有一些差别

在绝大多数情况下，函数的调用方式决定了 `this` 的值（运行时绑定）

`this` 关键字是函数运行时自动生成的一个内部对象，只能在函数内部使用，总指向调用它的对象；同时，`this`在函数执行过程中，`this`一旦被确定了，就不可以再更改

```javascript
function baz() {
    // 当前调用栈是：baz
    // 因此，当前调用位置是全局作用域
    
    console.log( "baz" );
    bar(); // <-- bar的调用位置
}

function bar() {
    // 当前调用栈是：baz --> bar
    // 因此，当前调用位置在baz中
    
    console.log( "bar" );
    foo(); // <-- foo的调用位置
}

function foo() {
    // 当前调用栈是：baz --> bar --> foo
    // 因此，当前调用位置在bar中
    
    console.log( "foo" );
}

baz(); // <-- baz的调用位置
```

#### 绑定规则：

根据不同的使用场合，`this`有不同的值，主要分为下面几种情况：

- **默认绑定**

  > 严格模式下，不能将全局对象用于默认绑定，this会绑定到`undefined`，只有函数运行在非严格模式下，默认绑定才能绑定到全局对象

- **隐式绑定**

  函数还可以作为某个对象的方法调用，这时`this`就指这个上级对象

  特殊情况：

  ```javascript
  var o = {
      a:10,
      b:{
          a:12,
          fn:function(){
              console.log(this.a); //undefined
              console.log(this); //window
          }
      }
  }
  var j = o.b.fn;
  j();
  ```

  此时`this`指向的是`window`，这里的大家需要记住，`this`永远指向的是最后调用它的对象，虽然`fn`是对象`b`的方法，但是`fn`赋值给`j`时候并没有执行，所以最终指向`window`

- **new绑定**

  通过构建函数`new`关键字生成一个实例对象，此时`this`指向这个实例对象

- **显示绑定**

  `apply()、call()、bind()`是函数的一个方法，作用是改变函数的调用对象。它的第一个参数就表示改变后的调用这个函数的对象。因此，这时`this`指的就是这第一个参数


## 5-5

### 如何理解闭包？

一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）

也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域

在 `JavaScript`中，每当创建一个函数，闭包就会在函数创建的同时被创建出来，作为函数内部与外部连接起来的一座桥梁

```javascript
function init() {
    var name = "Mozilla"; // name 是一个被 init 创建的局部变量
    function displayName() { // displayName() 是内部函数，一个闭包
        alert(name); // 使用了父函数中声明的变量
    }
    displayName();
}
init();
```

`displayName()` 没有自己的局部变量。然而，由于闭包的特性，它可以访问到外部函数的变量


## 5-4

### 深拷贝浅拷贝的区别？

#### 1、浅拷贝

浅拷贝，指的是创建新的数据，这个数据有着原始数据属性值的一份精确拷贝

如果属性是基本类型，拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址

即浅拷贝是拷贝一层，深层次的引用类型则共享内存地址

在`JavaScript`中，存在浅拷贝的现象有：

- `Object.assign`
- `Array.prototype.slice()`, `Array.prototype.concat()`
- 使用拓展运算符实现的复制

#### 2、深拷贝

深拷贝开辟一个新的栈，两个对象属完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性

常见的深拷贝方式有：

- _.cloneDeep()
- jQuery.extend()
- JSON.stringify()
- 手写循环递归

#### 3、区别

![img](https://static.vue-js.com/d9862c00-69b8-11eb-ab90-d9ae814b240d.png)

浅拷贝和深拷贝都创建出一个新的对象，但在复制对象属性的时候，行为就不一样

浅拷贝只复制属性指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存，修改对象属性会影响原对象；但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象

> - 浅拷贝是拷贝一层，属性为对象时，浅拷贝是复制，两个对象指向同一个地址
> - 深拷贝是递归拷贝深层次，属性为对象时，深拷贝是新开栈，两个对象指向不同的地址


## 5-3

### Vue3中Treeshaking特性？

`Tree shaking` 是一种通过清除多余代码方式来优化项目打包体积的技术，专业术语叫 `Dead code elimination`

简单来讲，就是在保持代码运行结果不变的前提下，去除无用的代码

如果把代码打包比作制作蛋糕，传统的方式是把鸡蛋（带壳）全部丢进去搅拌，然后放入烤箱，最后把（没有用的）蛋壳全部挑选并剔除出去

而`treeshaking`则是一开始就把有用的蛋白蛋黄（import）放入搅拌，最后直接作出蛋糕。也就是说 ，`tree shaking` 其实是找出使用的代码

`Tree shaking`是基于`ES6`模板语法（`import`与`exports`），主要是借助`ES6`模块的静态编译思想，在编译时就能确定模块的依赖关系，以及输入和输出的变量

`Tree shaking`无非就是做了两件事：

- 编译阶段利用`ES6 Module`判断哪些模块已经加载
- 判断那些模块和变量未被使用或者引用，进而删除对应代码

> 通过`Tree shaking`，`Vue3`给我们带来的好处是：
>
> - 减少程序体积（更小）
> - 减少程序执行时间（更快）
> - 便于将来对程序架构进行优化（更友好）


## 5-2

### SSR解决了什么问题？

SSR主要解决了以下两种问题：

- seo：搜索引擎优先爬取页面`HTML`结构，使用`ssr`时，服务端已经生成了和业务想关联的`HTML`，有利于`seo`
- 首屏呈现渲染：用户无需等待页面所有`js`加载完成就可以看到页面视图（压力来到了服务器，所以需要权衡哪些用服务端渲染，哪些交给客户端）

但是使用`SSR`同样存在以下的缺点：

- 复杂度：整个项目的复杂度
- 库的支持性，代码兼容
- 性能问题
  - 每个请求都是`n`个实例的创建，不然会污染，消耗会变得很大
  - 缓存 `node serve`、 `nginx`判断当前用户有没有过期，如果没过期的话就缓存，用刚刚的结果。
  - 降级：监控`cpu`、内存占用过多，就`spa`，返回单个的壳
- 服务器负载变大，相对于前后端分离服务器只需要提供静态资源来说，服务器负载更大，所以要慎重使用

所以在我们选择是否使用`SSR`前，我们需要慎重问问自己这些问题：

1. 需要`SEO`的页面是否只是少数几个，这些是否可以使用预渲染（Prerender SPA Plugin）实现
2. 首屏的请求响应逻辑是否复杂，数据返回是否大量且缓慢



## 5-1

### SSR是什么？

`Server-Side Rendering` 我们称其为SSR，意为服务端渲染

由服务侧完成页面的 HTML 结构拼接的页面处理技术，发送到浏览器，然后为其绑定状态与事件，成为完全可交互页面的过程

web的3个阶段的发展史：

- 传统服务端渲染SSR
  网页内容在服务端渲染完成，⼀次性传输到浏览器
  打开页面查看源码，浏览器拿到的是全部的dom结构
- 单页面应用SPA
  单页应用优秀的用户体验，使其逐渐成为主流，页面内容由JS渲染出来，这种方式称为客户端渲染
  打开页面查看源码，浏览器拿到的仅有宿主元素#app，并没有内容
- 服务端渲染SSR
  SSR解决方案，后端渲染出完整的首屏的dom结构返回，前端拿到的内容包括首屏及完整spa结构，应用激活后依然按照spa方式运行

> Vue SSR是一个在SPA上进行改良的服务端渲染
> 通过Vue SSR渲染的页面，需要在客户端激活才能实现交互
> Vue SSR将包含两部分：服务端渲染的首屏，包含交互的SPA
