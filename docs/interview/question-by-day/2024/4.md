---
readingTime: false
hidden: true
outline: 3
---

# 每日一题 - 202404

## 4-18

### HashMap 和 Hashtable 的区别

- HashMap 是基于哈希表实现的，每一个元素是一个key-value对，其内部通过单链表解决冲突问题，容量不足（超过了阀值）时，同样会自动增长。
- HashMap 是非线程安全的，只是用于单线程环境下，多线程环境下可以采用concurrent并发包下的concurrentHashMap。
- HashMap 实现了Serializable接口，因此它支持序列化，实现了Cloneable接口，能被克隆。
- HashMap 存数据的过程是：HashMap内部维护了一个存储数据的Entry数组，HashMap 采用链表解决冲突，每一个Entry本质上是一个单向链表。当准备添加一个key-value对时，首先通过hash(key)方法计算hash值，然后通过indexFor(hash,length)求该key-value对的存储位置，计算方法是先用hash&0x7FFFFFFF后，再对length取模，这就保证每一个key-value对都能存入HashMap中，当计算出的位置相同时，由于存入位置是一个链表，则把这个key-value对插入链表头。
- HashMap 中key和value都允许为null。key为null的键值对永远都放在以 `table[0]` 为头结点的链表中。


## 4-17

### 力扣题库-1410 HTML 实体解析器

[原题链接 - HTML 实体解析器](https://leetcode-cn.com/problems/html-entity-parser/)

**:fire: 题目：** 请实现一个 HTML 实体解析器，实体包括 `&quot;`，`&apos;`，`&amp;`，`&gt;`，`&lt;` 和 `&frasl;`。

#### 题解1

> 回家等通知写法

```java
public String entityParser(String text) {
    return text.replace("&quot;", "\"")
            .replace("&apos;", "'")
            .replace("&amp;", "&")
            .replace("&gt;", ">")
            .replace("&lt;", "<")
            .replace("&frasl;", "/");
}
```

#### 题解2

```java
public static String entityParser(String text) {
    int p = 0;
    StringBuilder stringBuilder = new StringBuilder();
    while (p < text.length()) {
        if (!"&".equals(text.substring(p, p + 1))) {
            stringBuilder.append(text.charAt(p));
            p++;
            continue;
        }
        if (text.length() >= p + 6 && "&quot;".equals(text.substring(p, p + 6))) {
            stringBuilder.append("\"");
            p += 6;
            continue;
        }
        if (text.length() >= p + 6 && "&apos;".equals(text.substring(p, p + 6))) {
            stringBuilder.append("'");
            p += 6;
            continue;
        }
        if (text.length() >= p + 5 && "&amp;".equals(text.substring(p, p + 5))) {
            stringBuilder.append("&");
            p += 5;
            continue;
        }
        if (text.length() >= p + 4 && "&gt;".equals(text.substring(p, p + 4))) {
            stringBuilder.append(">");
            p += 4;
            continue;
        }
        if (text.length() >= p + 4 && "&lt;".equals(text.substring(p, p + 4))) {
            stringBuilder.append("<");
            p += 4;
            continue;
        }
        if (text.length() >= p + 7 && "&frasl;".equals(text.substring(p, p + 7))) {
            stringBuilder.append("/");
            p += 7;
            continue;
        }
        stringBuilder.append(text.charAt(p));
        p++;
    }
    return stringBuilder.toString();
}
```

:fire: [查看我的题解](https://leetcode.cn/problems/html-entity-parser/solutions/2744042/stringbuilder-jie-jue-by-06jdn7fykv-ycrz)

## 4-16

### 什么是单调栈？

单调栈是指栈中的元素是单调递增或者单调递减的栈。主要应用场景是解决 `Next Greater Element` 问题，即找到数组中每个元素的下一个更大的元素。

单调栈的实现方式是使用栈来存储元素的索引，当遍历到一个新元素时，如果栈为空，则将元素的索引入栈；如果栈不为空，则比较栈顶元素和新元素的大小，
如果新元素大于栈顶元素，则将栈顶元素出栈，并将新元素的索引入栈，直到新元素小于栈顶元素。

## 4-15

### 力扣题库-121 买卖股票的最佳时机

[原题链接 - 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/description/)

**:fire: 题目：** 给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。

#### 解法1 暴力法

这道题双重循环很快就可以解决，但是会超时：

> 时间复杂度：$O(n^2)$
> 
> 空间复杂度：$O(1)$。

```java
public static int maxProfit(int[] prices) {
    int x = 0;
    for (int i = 0; i < prices.length; i++) {
        for (int j = i+1; j < prices.length; j++) {
            if (prices[j] > prices[i] ) {
                if (prices[j] - prices[i] > x) {
                    x = prices[j] - prices[i];
                }
            }
        }
    }
    return x;
}
```

#### 方法二：动态规划

在看完官方题解的思路之后，我自己写了一遍，如下：

> 时间复杂度：$O(n)$
> 
> 空间复杂度：$O(1)$

```java
public static int maxProfit(int[] prices) {
    int min = Integer.MAX_VALUE;
    int max = 0;
    for (int p : prices) {
        if (p < min) {
            min = p;
        } else if (p - min > max) {
            max = p - min;
        }
    }
    return max;
}
```


## 4-14

### HashMap get 方法的执行过程？

1. 计算键的哈希值： 首先，HashMap 会通过键的 hashCode() 方法计算键的哈希值。哈希值是一个整数，用于确定键在 HashMap 中的位置。 
2. 确定存储位置： 使用哈希值确定键在 HashMap 的存储桶（buckets）中的位置。HashMap 通过对哈希值进行一些位运算，将其映射到存储桶的索引上。 
3. 检索键值对： 一旦确定了存储位置，HashMap 会检查该位置上是否存在一个或多个键值对。如果存在多个键值对，可能会使用链表或树等数据结构来存储这些键值对。 
4. 比较键： 如果在指定位置找到了键值对，HashMap 会比较目标键和存储的键是否相等。这里使用的是键的 equals() 方法来进行比较。 
5. 返回值： 如果找到了匹配的键，HashMap 会返回对应的值；否则，返回 null，表示未找到匹配的键。

## 4-13

### HashMap put 方法的执行过程？

1. 计算 Key 的 Hash 值。
2. 根据 Hash 值计算出 Key 在数组中的位置，通常是通过取模运算（hash % 数组长度）来确定位置。
3. 如果该位置没有元素，直接插入。
4. 如果该位置有元素，判断 Key 是否相等，如果相等则覆盖 Value，如果不相等则处理冲突。
5. 通常使用链表或红黑树解决冲突，如果当前位置存在一个链表，则新插入的键值对会被插入到链表（或树）的尾部。
6. 如果链表长度超过阈值（通常为 8），链表会转换为红黑树。
7. 如果插入成功，返回 null，如果覆盖了 Value，则返回被覆盖的 Value。



## 4-12

### 什么是 CDN？

CDN（Content Delivery Network）即内容分发网络，是一种通过在网络中部署节点服务器，将内容缓存到离用户更近的位置，从而提高用户访问速度的技术。

CDN 的工作原理是将内容缓存到离用户更近的位置，当用户请求内容时，CDN 会根据用户的地理位置，选择离用户最近的节点服务器来提供内容，从而减少网络延迟，提高用户访问速度。


## 4-11

### 力扣题库-27 移除元素

[原题链接 - 移除元素](https://leetcode-cn.com/problems/remove-element/description/)

给定一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

必须仅用 O(1) 额外空间并 原地 修改输入数组。

#### 题解

这道题目相对简单，题目摆明了使用双指针，轻松拿捏:joy:。

```java
public static int removeElement(int[] nums, int val) {
    int p1 = 0, p2 = nums.length;
    while (p1 < p2) {
        if (nums[p1++] == val) {
            nums[--p1] = nums[--p2];
        }
    }
    return p1;
}
```

在力扣查看我的[详细题解](https://leetcode.cn/problems/remove-element/solutions/2734707/problem-27-yi-chu-yuan-su-shuang-zhi-zhe-e1f0)

## 4-10

### 合并和变基有什么区别？

**合并（merge）** 和 **变基（rebase）** 的最终目的都是整合来自不同分支的修改。

合并是一种非破坏性的操作，它不会对现有分支中的提交进行修改，而是创建一个新的提交来整合不同分支的修改。

变基会为原始分支中的每个提交创建全新的提交来重写项目历史记录，能够让代码提交记录更加清晰明了。

参考地址：[Merging vs. rebasing](https://www.atlassian.com/zh/git/tutorials/merging-vs-rebasing)

## 4-9

### 力扣题库-1 两数之和

[原题链接 - 两数之和](https://leetcode-cn.com/problems/two-sum/description/)

**:fire: 题目：** 给定一个整数数组 `nums` 和一个整数 `target`，请你在该数组中找出和为 `target` 的两个整数，并返回它们的数组下标。

#### 题解1 暴力方法

由于过于简单，所以不再赘述。

时间复杂度：$O(N^2)$ 其中 $N$ 是数组中的元素数量。最坏情况下数组中任意两个数都要被匹配一次。

空间复杂度：$O(1)$。

```java
public static int[] twoSum(int[] nums, int target) {
        for (int i = 0; i < nums.length; i++) {
            for (int i1 = 0; i1 < nums.length; i1++) {
                if (i == i1) {
                    continue;
                }
                if (nums[i] + nums[i1] == target) {
                    return new int[]{i, i1};
                }
            }
        }
        return null;
    }
```

#### 题解2 哈希表

对于哈希表的运用我还是不够熟练，这个题解是看完官方题解思路后完成的。

时间复杂度：$O(N)$ 。其中 $N$ 是数组中的元素数量。

空间复杂度：$O(N)$ 。其中 $N$ 是数组中的元素数量。

```java
public static int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            int complement = target - nums[i];
            if (map.containsKey(complement)) {
                return new int[]{map.get(complement), i};
            }
            map.put(nums[i], i);
        }
        return null;
    }
```

## 4-8

### 为什么推荐使用 isEmpty() 方法判空？

根据《阿里巴巴 Java 开发手册》：

> 判断所有集合内部的元素是否为空，使用 isEmpty() 方法，而不是 size()==0 的方式。

- `isEmpty()` 方法可读性更好，更优雅，
- `isEmpty()` 方法的时间复杂度是 O(1)，而 `size()` 方法在有些集合中的时间复杂度不是 O(1)。

## 4-7

### 力扣题库-88 合并两个有序数组

[原题链接 - 合并两个有序数组](https://leetcode.cn/problems/merge-sorted-array/description/)

**:fire: 题目：** 给定两个 **非递减顺序** 排列的整数数组 `nums1` 和 `nums2`，以及其长度 `m`、`n`，需要将 `nums2` 合并到 `nums1` 中，使 `nums1` 成为一个有序数组。


#### 题解 1

如果不考虑时间及空间复杂度，可以直接将 `nums2` 数组拷贝到 `nums1` 数组后，再进行排序：

```java

public void merge(int[] nums1, int m, int[] nums2, int n) {
    if (n >= 0) System.arraycopy(nums2, 0, nums1, m, n);
    Arrays.sort(nums1);
}
```
#### 题解 2

基于[官方题解3](https://leetcode.cn/problems/merge-sorted-array/solutions/666608/he-bing-liang-ge-you-xu-shu-zu-by-leetco-rrb0)
双指针的结题思路，进行简单优化得出如下空间复杂度为 O(1) 的解法：

```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        // 创建两个双指针指向各个数组的末尾
        int p1 = m - 1, p2 = n - 1;
        while (p1 >= 0 || p2 >= 0) {
            // 如果一个数组遍历结束，则直接保留剩余元素即可。
            if (p2 < 0) return;
            if (p1 < 0) {
                nums1[p2] = nums2[p2--];
            } else {
                // 从后往前遍历，比较大小，将较大的元素放到 nums1 的末尾，并移动指正
                nums1[p1 + p2 + 1] = nums1[p1] > nums2[p2] ? nums1[p1--] : nums2[p2--];
            }
        }
    }
}
```

[:heartpulse: 点击查看详细题解](https://leetcode.cn/problems/merge-sorted-array/solutions/2727444/ti-jie-3-jian-hua-ban-by-06jdn7fykv-p1z2)

## 4-6

### `BigDecimal` 类有哪些常见方法。

- `add(BigDecimal value)`：加法
- `subtract(BigDecimal value)`：减法
- `multiply(BigDecimal value)`：乘法
- `divide(BigDecimal value)`：除法
- `pow(int n)`：幂运算
- `abs()`：绝对值
- `negate()`：取反
- `setScale(int newScale, RoundingMode roundingMode)`：设置精度
- `compareTo(BigDecimal value)`：比较大小

## 4-5

### 什么是 `BigDecimal` 类？

《阿里巴巴 Java 开发手册》中提到：“为了避免精度丢失，可以使用 BigDecimal 来进行浮点数的运算”。

这是由于计算机中，十进制小数无法精确表示，会存在类似于 `2.0f - 1.9f != 1.8f - 1.7f`的情况，所以在 JAVA 中提供了 `BigDecimal` 类来解决这个问题。

`BigDecimal` 类是 JAVA 中用于精确计算浮点数的类，它提供了大量的方法用于精确计算浮点数，避免了浮点数计算时的精度丢失问题。

## 4-4

### JAVA 如何做序列化？

在 JAVA 中，如果要对一个对象进行序列化，需要实现 `java.io.Serializable` 接口，并且添加 `serialVersionUID` 字段。

```java
import java.io.Serial;
import java.io.Serializable;


public class User implements Serializable {
    @Serial // java14 引入的注解，表示该字段是序列化的一部分。详见 {java.io.Serial}
    private static final long serialVersionUID = 1L;
    private String name;
    private int age;
    private String address;

    public User(String name, int age, String address) {
        this.name = name;
        this.age = age;
        this.address = address;
    }
}
```


## 4-3

### 什么是序列化和反序列化？

在 JAVA 中，如果需要将 JAVA 对象持久存储，或者在网络传输，就需要将对象转变为为字节流，这个过程就是序列化。

将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程，就是反序列化。

## 4-2

### JAVA 中有没有引用传递？

JAVA 中没有引用传递，只有值传递。

```java

 public static void main(String[] args) {
      int[] arr = { 1, 2, 3, 4, 5 };
      System.out.println(arr[0]);
      change(arr);
      System.out.println(arr[0]);
  }

  public static void change(int[] array) {
      // 将数组的第一个元素变为0
      array[0] = 0;
  }
```

上方案例中，输出的结果为 `1 0` ，说明在 `change` 方法中修改了数组的第一个元素，但是并没有改变数组的引用。

## 4-1

### 值传递&引用传递
 
- 值传递：传递的是实际的值，会创建一个副本，对形参的修改不会影响实参。
- 引用传递：传递的是实际的地址，对形参的修改会影响实参。

