---
readingTime: false
hidden: true
outline: 3
---

# 每日一题 - 202404

## 4-16

### 证明对任意常数 k， 如下等式成立：$log^kN = O(N)$

> 这道题来自《算法与数据结构 - JAVA 语言描述》，看着标准答案还是不会，先记着。。。

#### 题解

根据大 O 表示法的定义，对于任意常数 $k$，只要存在常数 $c$ 和 $N_0$，使得当 $N > N_0$ 时，$log^kN \leq cN$ 成立，那么 $log^kN = O(N)$。

我们可以通过换底公式，将 $log^kN$ 转换为 $logN$ 的形式，即 $log^kN = \frac{logN}{logk}$。

所以，只要存在常数 $c$ 和 $N_0$，使得当 $N > N_0$ 时，$\frac{logN}{logk} \leq cN$ 成立，那么 $log^kN = O(N)$。

根据换底公式，我们可以将 $\frac{logN}{logk}$ 转换为 $logN$ 的形式，即 $log^kN = \frac{logN}{logk} = \frac{logN}{log2} * \frac{log2}{logk} = log2 * \frac{logN}{logk}$。

所以，只要存在常数 $c$ 和 $N_0$，使得当 $N > N_0$ 时，$log2 * \frac{logN}{logk} \leq cN$ 成立，那么 $log^kN = O(N)$。

因此，对于任意常数 $k$，$log^kN = O(N)$ 成立。

::: tip 提示
以下为 ChatGpt 生成。
:::

要证明$log^k N = O(N)$，我们可以使用定义来进行证明。根据大O符号的定义，如果存在常数$c$和$N_0$，使得当$N>N_0$时，$|f(N)| \leq c \cdot g(N)$成立，则可以说$f(N) = O(g(N))$。

在这里，$f(N) = \log^k N$，$g(N) = N$。我们需要找到适当的$c$和$N_0$，使得对于足够大的$N$，$\log^k N \leq c \cdot N$。

考虑到$log^k N$和$N$的增长率，我们可以尝试用一个$c$来表示$log^k N$的上界。即，$c = \log^k N$。

所以我们需要证明$\log^k N \leq \log^k N \cdot N$。

这里我们可以看到，当$N$足够大时，$\log^k N \leq \log^k N \cdot N$成立，因为$log^k N$是一个递增函数，而$N$是线性增长的。

所以我们可以选择$c = 1$和$N_0 = 1$，因为当$N \geq 1$时，上述不等式始终成立。

因此，我们证明了$log^k N = O(N)$。

## 4-15

### 力扣题库-121 买卖股票的最佳时机

[原题链接 - 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/description/)

**:fire: 题目：** 给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。

#### 解法1 暴力法

这道题双重循环很快就可以解决，但是会超时：

> 时间复杂度：$O(n^2)$
> 
> 空间复杂度：$O(1)$。

```java
public static int maxProfit(int[] prices) {
    int x = 0;
    for (int i = 0; i < prices.length; i++) {
        for (int j = i+1; j < prices.length; j++) {
            if (prices[j] > prices[i] ) {
                if (prices[j] - prices[i] > x) {
                    x = prices[j] - prices[i];
                }
            }
        }
    }
    return x;
}
```

#### 方法二：动态规划

在看完官方题解的思路之后，我自己写了一遍，如下：

> 时间复杂度：$O(n)$
> 
> 空间复杂度：$O(1)$

```java
public static int maxProfit(int[] prices) {
    int min = Integer.MAX_VALUE;
    int max = 0;
    for (int p : prices) {
        if (p < min) {
            min = p;
        } else if (p - min > max) {
            max = p - min;
        }
    }
    return max;
}
```


## 4-14

### HashMap get 方法的执行过程？

1. 计算键的哈希值： 首先，HashMap 会通过键的 hashCode() 方法计算键的哈希值。哈希值是一个整数，用于确定键在 HashMap 中的位置。 
2. 确定存储位置： 使用哈希值确定键在 HashMap 的存储桶（buckets）中的位置。HashMap 通过对哈希值进行一些位运算，将其映射到存储桶的索引上。 
3. 检索键值对： 一旦确定了存储位置，HashMap 会检查该位置上是否存在一个或多个键值对。如果存在多个键值对，可能会使用链表或树等数据结构来存储这些键值对。 
4. 比较键： 如果在指定位置找到了键值对，HashMap 会比较目标键和存储的键是否相等。这里使用的是键的 equals() 方法来进行比较。 
5. 返回值： 如果找到了匹配的键，HashMap 会返回对应的值；否则，返回 null，表示未找到匹配的键。

## 4-13

### HashMap put 方法的执行过程？

1. 计算 Key 的 Hash 值。
2. 根据 Hash 值计算出 Key 在数组中的位置，通常是通过取模运算（hash % 数组长度）来确定位置。
3. 如果该位置没有元素，直接插入。
4. 如果该位置有元素，判断 Key 是否相等，如果相等则覆盖 Value，如果不相等则处理冲突。
5. 通常使用链表或红黑树解决冲突，如果当前位置存在一个链表，则新插入的键值对会被插入到链表（或树）的尾部。
6. 如果链表长度超过阈值（通常为 8），链表会转换为红黑树。
7. 如果插入成功，返回 null，如果覆盖了 Value，则返回被覆盖的 Value。



## 4-12

### 什么是 CDN？

CDN（Content Delivery Network）即内容分发网络，是一种通过在网络中部署节点服务器，将内容缓存到离用户更近的位置，从而提高用户访问速度的技术。

CDN 的工作原理是将内容缓存到离用户更近的位置，当用户请求内容时，CDN 会根据用户的地理位置，选择离用户最近的节点服务器来提供内容，从而减少网络延迟，提高用户访问速度。


## 4-11

### 力扣题库-27 移除元素

[原题链接 - 移除元素](https://leetcode-cn.com/problems/remove-element/description/)

给定一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

必须仅用 O(1) 额外空间并 原地 修改输入数组。

#### 题解

这道题目相对简单，题目摆明了使用双指针，轻松拿捏:joy:。

```java
public static int removeElement(int[] nums, int val) {
    int p1 = 0, p2 = nums.length;
    while (p1 < p2) {
        if (nums[p1++] == val) {
            nums[--p1] = nums[--p2];
        }
    }
    return p1;
}
```

在力扣查看我的[详细题解](https://leetcode.cn/problems/remove-element/solutions/2734707/problem-27-yi-chu-yuan-su-shuang-zhi-zhe-e1f0)

## 4-10

### 合并和变基有什么区别？

**合并（merge）** 和 **变基（rebase）** 的最终目的都是整合来自不同分支的修改。

合并是一种非破坏性的操作，它不会对现有分支中的提交进行修改，而是创建一个新的提交来整合不同分支的修改。

变基会为原始分支中的每个提交创建全新的提交来重写项目历史记录，能够让代码提交记录更加清晰明了。

参考地址：[Merging vs. rebasing](https://www.atlassian.com/zh/git/tutorials/merging-vs-rebasing)

## 4-9

### 力扣题库-1 两数之和

[原题链接 - 两数之和](https://leetcode-cn.com/problems/two-sum/description/)

**:fire: 题目：** 给定一个整数数组 `nums` 和一个整数 `target`，请你在该数组中找出和为 `target` 的两个整数，并返回它们的数组下标。

#### 题解1 暴力方法

由于过于简单，所以不再赘述。

时间复杂度：$O(N^2)$ 其中 $N$ 是数组中的元素数量。最坏情况下数组中任意两个数都要被匹配一次。

空间复杂度：$O(1)$。

```java
public static int[] twoSum(int[] nums, int target) {
        for (int i = 0; i < nums.length; i++) {
            for (int i1 = 0; i1 < nums.length; i1++) {
                if (i == i1) {
                    continue;
                }
                if (nums[i] + nums[i1] == target) {
                    return new int[]{i, i1};
                }
            }
        }
        return null;
    }
```

#### 题解2 哈希表

对于哈希表的运用我还是不够熟练，这个题解是看完官方题解思路后完成的。

时间复杂度：$O(N)$ 。其中 $N$ 是数组中的元素数量。

空间复杂度：$O(N)$ 。其中 $N$ 是数组中的元素数量。

```java
public static int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            int complement = target - nums[i];
            if (map.containsKey(complement)) {
                return new int[]{map.get(complement), i};
            }
            map.put(nums[i], i);
        }
        return null;
    }
```

## 4-8

### 为什么推荐使用 isEmpty() 方法判空？

根据《阿里巴巴 Java 开发手册》：

> 判断所有集合内部的元素是否为空，使用 isEmpty() 方法，而不是 size()==0 的方式。

- `isEmpty()` 方法可读性更好，更优雅，
- `isEmpty()` 方法的时间复杂度是 O(1)，而 `size()` 方法在有些集合中的时间复杂度不是 O(1)。

## 4-7

### 力扣题库-88 合并两个有序数组

[原题链接 - 合并两个有序数组](https://leetcode.cn/problems/merge-sorted-array/description/)

**:fire: 题目：** 给定两个 **非递减顺序** 排列的整数数组 `nums1` 和 `nums2`，以及其长度 `m`、`n`，需要将 `nums2` 合并到 `nums1` 中，使 `nums1` 成为一个有序数组。


#### 题解 1

如果不考虑时间及空间复杂度，可以直接将 `nums2` 数组拷贝到 `nums1` 数组后，再进行排序：

```java
if (n >= 0) System.arraycopy(nums2, 0, nums1, m, n);
Arrays.sort(nums1);
```
#### 题解 2

基于[官方题解3](https://leetcode.cn/problems/merge-sorted-array/solutions/666608/he-bing-liang-ge-you-xu-shu-zu-by-leetco-rrb0)
双指针的结题思路，进行简单优化得出如下空间复杂度为 O(1) 的解法：

```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        // 创建两个双指针指向各个数组的末尾
        int p1 = m - 1, p2 = n - 1;
        while (p1 >= 0 || p2 >= 0) {
            // 如果一个数组遍历结束，则直接保留剩余元素即可。
            if (p2 < 0) return;
            if (p1 < 0) {
                nums1[p2] = nums2[p2--];
            } else {
                // 从后往前遍历，比较大小，将较大的元素放到 nums1 的末尾，并移动指正
                nums1[p1 + p2 + 1] = nums1[p1] > nums2[p2] ? nums1[p1--] : nums2[p2--];
            }
        }
    }
}
```

[:heartpulse: 点击查看详细题解](https://leetcode.cn/problems/merge-sorted-array/solutions/2727444/ti-jie-3-jian-hua-ban-by-06jdn7fykv-p1z2)

## 4-6

### `BigDecimal` 类有哪些常见方法。

- `add(BigDecimal value)`：加法
- `subtract(BigDecimal value)`：减法
- `multiply(BigDecimal value)`：乘法
- `divide(BigDecimal value)`：除法
- `pow(int n)`：幂运算
- `abs()`：绝对值
- `negate()`：取反
- `setScale(int newScale, RoundingMode roundingMode)`：设置精度
- `compareTo(BigDecimal value)`：比较大小

## 4-5

### 什么是 `BigDecimal` 类？

《阿里巴巴 Java 开发手册》中提到：“为了避免精度丢失，可以使用 BigDecimal 来进行浮点数的运算”。

这是由于计算机中，十进制小数无法精确表示，会存在类似于 `2.0f - 1.9f != 1.8f - 1.7f`的情况，所以在 JAVA 中提供了 `BigDecimal` 类来解决这个问题。

`BigDecimal` 类是 JAVA 中用于精确计算浮点数的类，它提供了大量的方法用于精确计算浮点数，避免了浮点数计算时的精度丢失问题。

## 4-4

### JAVA 如何做序列化？

在 JAVA 中，如果要对一个对象进行序列化，需要实现 `java.io.Serializable` 接口，并且添加 `serialVersionUID` 字段。

```java
import java.io.Serial;
import java.io.Serializable;


public class User implements Serializable {
    @Serial // java14 引入的注解，表示该字段是序列化的一部分。详见 {java.io.Serial}
    private static final long serialVersionUID = 1L;
    private String name;
    private int age;
    private String address;

    public User(String name, int age, String address) {
        this.name = name;
        this.age = age;
        this.address = address;
    }
}
```


## 4-3

### 什么是序列化和反序列化？

在 JAVA 中，如果需要将 JAVA 对象持久存储，或者在网络传输，就需要将对象转变为为字节流，这个过程就是序列化。

将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程，就是反序列化。

## 4-2

### JAVA 中有没有引用传递？

JAVA 中没有引用传递，只有值传递。

```java

 public static void main(String[] args) {
      int[] arr = { 1, 2, 3, 4, 5 };
      System.out.println(arr[0]);
      change(arr);
      System.out.println(arr[0]);
  }

  public static void change(int[] array) {
      // 将数组的第一个元素变为0
      array[0] = 0;
  }
```

上方案例中，输出的结果为 `1 0` ，说明在 `change` 方法中修改了数组的第一个元素，但是并没有改变数组的引用。

## 4-1

### 值传递&引用传递
 
- 值传递：传递的是实际的值，会创建一个副本，对形参的修改不会影响实参。
- 引用传递：传递的是实际的地址，对形参的修改会影响实参。

