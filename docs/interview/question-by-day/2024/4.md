---
readingTime: false
hidden: true
outline: 3
---

# 每日一题 - 202404

## 4-9

### 力扣题库-1 两数之和

[原题链接 - 两数之和](https://leetcode-cn.com/problems/two-sum/description/)

**:fire: 题目：** 给定一个整数数组 `nums` 和一个整数 `target`，请你在该数组中找出和为 `target` 的两个整数，并返回它们的数组下标。

#### 题解1 暴力方法

由于过于简单，所以不再赘述。

时间复杂度：$O(N^2)$ 其中 $N$ 是数组中的元素数量。最坏情况下数组中任意两个数都要被匹配一次。

空间复杂度：$O(1)$。

```java
public static int[] twoSum(int[] nums, int target) {
        for (int i = 0; i < nums.length; i++) {
            for (int i1 = 0; i1 < nums.length; i1++) {
                if (i == i1) {
                    continue;
                }
                if (nums[i] + nums[i1] == target) {
                    return new int[]{i, i1};
                }
            }
        }
        return null;
    }
```

#### 题解2 哈希表

对于哈希表的运用我还是不够熟练，这个题解是看完官方题解思路后完成的。

时间复杂度：$O(N)$ 。其中 $N$ 是数组中的元素数量。

空间复杂度：$O(N)$ 。其中 $N$ 是数组中的元素数量。

```java
public static int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            int complement = target - nums[i];
            if (map.containsKey(complement)) {
                return new int[]{map.get(complement), i};
            }
            map.put(nums[i], i);
        }
        return null;
    }
```

## 4-8

### 为什么推荐使用 isEmpty() 方法判空？

根据《阿里巴巴 Java 开发手册》：

> 判断所有集合内部的元素是否为空，使用 isEmpty() 方法，而不是 size()==0 的方式。

- `isEmpty()` 方法可读性更好，更优雅，
- `isEmpty()` 方法的时间复杂度是 O(1)，而 `size()` 方法在有些集合中的时间复杂度不是 O(1)。

## 4-7

### 力扣题库-88 合并两个有序数组

[原题链接 - 合并两个有序数组](https://leetcode.cn/problems/merge-sorted-array/description/)

**:fire: 题目：** 给定两个 **非递减顺序** 排列的整数数组 `nums1` 和 `nums2`，以及其长度 `m`、`n`，需要将 `nums2` 合并到 `nums1` 中，使 `nums1` 成为一个有序数组。


#### 题解 1

如果不考虑时间及空间复杂度，可以直接将 `nums2` 数组拷贝到 `nums1` 数组后，再进行排序：

```java
if (n >= 0) System.arraycopy(nums2, 0, nums1, m, n);
Arrays.sort(nums1);
```
#### 题解 2

基于[官方题解3](https://leetcode.cn/problems/merge-sorted-array/solutions/666608/he-bing-liang-ge-you-xu-shu-zu-by-leetco-rrb0)
双指针的结题思路，进行简单优化得出如下空间复杂度为 O(1) 的解法：

```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        // 创建两个双指针指向各个数组的末尾
        int p1 = m - 1, p2 = n - 1;
        while (p1 >= 0 || p2 >= 0) {
            // 如果一个数组遍历结束，则直接保留剩余元素即可。
            if (p2 < 0) return;
            if (p1 < 0) {
                nums1[p2] = nums2[p2--];
            } else {
                // 从后往前遍历，比较大小，将较大的元素放到 nums1 的末尾，并移动指正
                nums1[p1 + p2 + 1] = nums1[p1] > nums2[p2] ? nums1[p1--] : nums2[p2--];
            }
        }
    }
}
```

[:heartpulse: 点击查看详细题解](https://leetcode.cn/problems/merge-sorted-array/solutions/2727444/ti-jie-3-jian-hua-ban-by-06jdn7fykv-p1z2)

## 4-6

### `BigDecimal` 类有哪些常见方法。

- `add(BigDecimal value)`：加法
- `subtract(BigDecimal value)`：减法
- `multiply(BigDecimal value)`：乘法
- `divide(BigDecimal value)`：除法
- `pow(int n)`：幂运算
- `abs()`：绝对值
- `negate()`：取反
- `setScale(int newScale, RoundingMode roundingMode)`：设置精度
- `compareTo(BigDecimal value)`：比较大小

## 4-5

### 什么是 `BigDecimal` 类？

《阿里巴巴 Java 开发手册》中提到：“为了避免精度丢失，可以使用 BigDecimal 来进行浮点数的运算”。

这是由于计算机中，十进制小数无法精确表示，会存在类似于 `2.0f - 1.9f != 1.8f - 1.7f`的情况，所以在 JAVA 中提供了 `BigDecimal` 类来解决这个问题。

`BigDecimal` 类是 JAVA 中用于精确计算浮点数的类，它提供了大量的方法用于精确计算浮点数，避免了浮点数计算时的精度丢失问题。

## 4-4

### JAVA 如何做序列化？

在 JAVA 中，如果要对一个对象进行序列化，需要实现 `java.io.Serializable` 接口，并且添加 `serialVersionUID` 字段。

```java
import java.io.Serial;
import java.io.Serializable;


public class User implements Serializable {
    @Serial // java14 引入的注解，表示该字段是序列化的一部分。详见 {java.io.Serial}
    private static final long serialVersionUID = 1L;
    private String name;
    private int age;
    private String address;

    public User(String name, int age, String address) {
        this.name = name;
        this.age = age;
        this.address = address;
    }
}
```


## 4-3

### 什么是序列化和反序列化？

在 JAVA 中，如果需要将 JAVA 对象持久存储，或者在网络传输，就需要将对象转变为为字节流，这个过程就是序列化。

将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程，就是反序列化。

## 4-2

### JAVA 中有没有引用传递？

JAVA 中没有引用传递，只有值传递。

```java

 public static void main(String[] args) {
      int[] arr = { 1, 2, 3, 4, 5 };
      System.out.println(arr[0]);
      change(arr);
      System.out.println(arr[0]);
  }

  public static void change(int[] array) {
      // 将数组的第一个元素变为0
      array[0] = 0;
  }
```

上方案例中，输出的结果为 `1 0` ，说明在 `change` 方法中修改了数组的第一个元素，但是并没有改变数组的引用。

## 4-1

### 值传递&引用传递
 
- 值传递：传递的是实际的值，会创建一个副本，对形参的修改不会影响实参。
- 引用传递：传递的是实际的地址，对形参的修改会影响实参。

