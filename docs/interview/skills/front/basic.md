---
readingTime: false
hidden: true
outline: 3
---

## vue

### vue的响应式原理

Vue在初始化数据时，会遍历组件的data对象，并使用`Object.defineProperty`重新定义data中的所有属性，将其所有属性值转化为getter和setter的形式。当页面使用对应属性时，首先会进行依赖收集(收集当前组件的`watcher`)如果属性发生变化会通知相关依赖进行更新操作。

Vue3.x改用`Proxy`替代Object.defineProperty。因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。

> Proxy只会代理对象的第一层，Vue3是怎样处理的?
>
> 判断当前Reflect.get的返回值是否为Object，如果是则再通过`reactive`方法做代理， 这样就实现了深度观测。
>
> 监测数组的时候可能触发多次get/set，如何防止多次触发？
>
> 判断key是否为当前被代理对象target自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行trigger。


### vue组件的通信方式

#### （1）使用Props（属性）：

- 父组件可以通过在子组件上绑定属性（props）来向子组件传递数据。

- 子组件通过在模板中使用props来访问这些属性。

- 这是一种父向子组件传递数据的单向通信方式。

  > 父->子`props`，子->父 `$on、$emit`
  >
  > 获取父子组件实例 `$parent、$children`

#### （2）使用自定义事件：

- 子组件可以触发自定义事件，而父组件可以监听这些事件。
- 这允许子组件向父组件发送消息。
- 这是一种子向父组件传递数据的方式。

#### （3）使用`$refs`：

- 父组件可以通过`ref`属性引用子组件，并直接访问子组件的属性和方法。
- 这是一种直接的通信方式，但通常不推荐在多个子组件之间使用。

#### （4）使用Vuex（状态管理库）：

- 如果父子组件之间的通信较复杂，或者涉及多个组件，可以使用Vuex来实现全局状态管理。
- Vuex允许不同组件共享数据，并通过触发和监听事件来进行通信。

这些方法中的选择取决于您的具体需求和组件之间的关系。`在大多数情况下，使用Props和自定义事件是足够`的，但在更复杂的情况下，考虑使用Vuex或其他适当的通信模式。


### v-if和v-show的区别

#### （1）共同点

> `v-show` 与 `v-if` 的作用效果是相同的(不含v-else)，都能控制元素在页面是否显示
>
> 用法上也是相同的：
>
> - 当表达式为`true`的时候，都会占据页面的位置
> - 当表达式都为`false`时，都不会占据页面位置

#### （2）不同点

> `v-show`隐藏则是为该元素添加`css--display:none`，`dom`元素依旧还在。
>
> `v-if`显示隐藏是将`dom`元素整个添加或删除。
>
> `v-if`有更高的切换消耗；`v-show`有更高的初始渲染消耗；


### nextTick的作用

在下次 DOM 更新循环结束之后执行延迟回调。nextTick主要使用了宏任务和微任务。根据执行环境分别尝试采用

Promise
MutationObserver
setImmediate
如果以上都不行则采用setTimeout

定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。


### null和undefined的区别

#### 相同点：

null和undefined都属于基本数据类型，都分别只有一个值：null和undefined

#### 不同点：

- null的定义是空对象，undefined的定义是未定义

> 当变量声明后但未定义时会返回undefined；
>
> null主要用于赋值给一些可能返回对象的变量作为初始值

- undefined 在 JavaScript 中不是一个保留字，可以作为变量名，但会影响对undefined的值的判断；

- 使用typeof进行类型判断时，null类型会返回`Object`
- 两者进行比较时，双等号返回true，三等号返回false

```javascript
null == undefined   //true
null === undefined  //false
```

### 比较操作符 `===`、`==` 的区别

- 使用双等号（==）进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较。
- 使用三等号（===）进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 false。
- 使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN是相等的

> `===`只判断值不判断类型
>
> `==`既判断值又判断类型


### 如何让css仅在当前组件内起作用

在`<style></style>`标签下添加`scoped`

>  <style scoped></style>

### vue修饰符

#### （1）事件修饰符

在事件处理程序中调用 *event.preventDefault* 或 *event.stopPropagation* 方法是非常常见的需求。尽管可以在 *methods* 中轻松实现这点，但更好的方式是：*methods* 只有纯粹的数据逻辑，而不是去处理 *DOM* 事件细节。

常见的事件修饰符如下：

- *.stop*：阻止冒泡。
- *.prevent*：阻止默认事件。
- *.capture*：使用事件捕获模式。
- *.self*：只在当前元素本身触发。
- *.once*：只触发一次。
- *.passive*：默认行为将会立即触发。

#### （2）按键修饰符

在 *vue* 中还提供了有鼠标修饰符，键值修饰符，系统修饰符等功能。

- .*left*：左键
- .*right*：右键
- .*middle*：滚轮
- .*enter*：回车
- .*tab*：制表键
- .*delete*：捕获 “删除” 和 “退格” 键
- .*esc*：返回
- .*space*：空格
- .*up*：上
- .*down*：下
- .*left*：左
- .*right*：右
- .*ctrl*：*ctrl* 键
- .*alt*：*alt* 键
- .*shift*：*shift* 键
- .*meta*：*meta* 键

#### （3）表单修饰符

常见的有 *.lazy*、 *.number* 和 *.trim*。

- .*lazy*：在文本框失去焦点时才会渲染
- .*number*：将文本框中所输入的内容转换为number类型
- .*trim*：可以自动过滤输入首尾的空格


###  如何实现vue项目中的性能优化

##### （1）编码阶段

- 尽量减少 *data* 中的数据，*data* 中的数据都会增加 *getter* 和 *setter*，会收集对应的 *watcher*
- *v-if* 和 *v-for* 不能连用
- 如果需要使用 *v-for* 给每项元素绑定事件时使用事件代理
- *SPA* 页面采用 *keep-alive* 缓存组件
- 在更多的情况下，使用 *v-if* 替代 *v-show*
- *key* 保证唯一
- 使用路由懒加载、异步组件
- 防抖、节流
- 第三方模块按需导入
- 长列表滚动到可视区域动态加载
- 图片懒加载

##### （2）*SEO\* 优化

- 预渲染
- 服务端渲染 *SSR*

##### （3）打包优化

- 压缩代码
- *Tree Shaking/Scope Hoisting*
- 使用 *cdn* 加载第三方模块
- 多线程打包 *happypack*
- *splitChunks* 抽离公共文件
- *sourceMap* 优化

##### （4）用户体验

- 骨架屏
- *PWA*

还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启 gzip 压缩等。

### vue中的spa引用如何优化首屏加载速度

优化首屏加载可以从这几个方面开始：

- 请求优化：`CDN` 将第三方的类库放到 CDN 上，能够大幅度减少生产环境中的项目体积，另外 CDN 能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。
- 缓存：将长时间不会改变的第三方类库或者静态资源设置为强缓存，将 max-age 设置为一个非常长的时间，再将访问路径加上哈希达到哈希值变了以后保证获取到最新资源，好的缓存策略有助于减轻服务器的压力，并且显著的提升用户的体验
- gzip：开启 `gzip` 压缩，通常开启 gzip 压缩能够有效的缩小传输资源的大小。
- http2：如果系统首屏同一时间需要加载的静态资源非常多，但是浏览器对同域名的` tcp `连接数量是有限制的(chrome 为 6 个)超过规定数量的 tcp 连接，则必须要等到之前的请求收到响应后才能继续发送，而 http2 则可以在多个 tcp 连接中并发多个请求没有限制，在一些网络较差的环境开启 http2 性能提升尤为明显。
- 懒加载：当 url 匹配到相应的路径时，通过` import `动态加载页面组件，这样首屏的代码量会大幅减少，webpack 会把动态加载的页面组件分离成单独的一个 chunk.js 文件
- 预渲染：由于浏览器在渲染出页面之前，需要先加载和解析相应的 html、css 和 js 文件，为此会有一段白屏的时间，可以添加loading，或者骨架屏幕尽可能的减少白屏对用户的影响体积优化
- 合理使用第三方库：对于一些第三方 ui 框架、类库，尽量使用按需加载，减少打包体积
- 使用可视化工具分析打包后的模块体积：webpack-bundle- analyzer 这个插件在每次打包后能够更加直观的分析打包后模块的体积，再对其中比较大的模块进行优化
- 提高代码使用率：利用代码分割，将脚本中无需立即调用的代码在代码构建时转变为异步加载的过程
- 封装：构建良好的项目架构，按照项目需求就行全局组件，插件，过滤器，指令，utils 等做一 些公共封装，可以有效减少我们的代码量，而且更容易维护资源优化
- 图片懒加载：使用图片懒加载可以优化同一时间减少 http 请求开销，避免显示图片导致的画面抖动，提高用户体验
- 使用 svg 图标：相对于用一张图片来表示图标，svg 拥有更好的图片质量，体积更小，并且不需要开启额外的 http 请求
- 压缩图片：可以使用 image-webpack-loader，在用户肉眼分辨不清的情况下一定程度上压缩图片


